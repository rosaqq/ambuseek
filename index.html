<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Graph Visualizer + A* Pathfinder</title>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vis-network@9.1.6/dist/vis-network.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/vis-network@9.1.6/styles/vis-network.min.css" rel="stylesheet">
    <style>
        body { font-family: system-ui, sans-serif; margin: 2rem; }
        #network { width: 100%; height: 600px; border: 1px solid #ccc; margin-top: 1rem; }
        .inputs { margin-bottom: 1rem; }
    </style>
</head>
<body>
<h1>Graph Visualizer + A* Pathfinder</h1>

<div class="inputs">
    <label>Nodes CSV (pontos.csv): <input type="file" id="nodesFile" accept=".csv"></label><br><br>
    <label>Edges CSV (ruas.csv): <input type="file" id="edgesFile" accept=".csv"></label><br><br>
    <label>Info CSV (optional): <input type="file" id="infoFile" accept=".csv"></label><br><br>
    <button id="loadBtn">Load Graph</button>
</div>

<div id="network"></div>

<div class="inputs">
    <h3>Find the shortest path</h3>
    <label>Start node:
        <select id="startNode"></select>
    </label>
    <label>Goal node:
        <select id="goalNode"></select>
    </label>

    <button id="findPathBtn">Find Path</button>
    <button id="resetColorsBtn">Reset Colors</button>
    <button id="simulateBtn">Run Simulation</button>
</div>

<script>
    let nodes = [], edges = [], network;
    const container = document.getElementById('network');

    document.getElementById('loadBtn').addEventListener('click', async () => {
        const nodeFile = document.getElementById('nodesFile').files[0];
        const edgeFile = document.getElementById('edgesFile').files[0];
        const infoFile = document.getElementById('infoFile').files[0];
        if (!nodeFile || !edgeFile) return alert("Select both nodes and edges CSV files!");

        const [nodeResults, edgeResults, infoResults] = await Promise.all([
            parseCSV(nodeFile),
            parseCSV(edgeFile),
            infoFile ? parseCSV(infoFile) : Promise.resolve({ data: [] })
        ]);

        // --- Load nodes ---
        nodes = nodeResults.data.map(r => ({
            id: parseInt(r.id),
            type: String(r.tipo),
            label: String(r.nome),
            score: parseInt(r.prioridade),
            cost: parseFloat(r.tempo_cuidados_minimos),
            color: r.tipo && r.tipo.toLowerCase() === "hospital" ? "#ffc8c8" : "#97C2FC"
        }));

        // --- Load edges ---
        edges = edgeResults.data.map(r => ({
            from: parseInt(r.ponto_origem),
            to: parseInt(r.ponto_destino),
            value: parseInt(r.tempo_transporte),
            color: "#97C2FC" // default blue
        }));

        // --- Load info CSV (optional) ---
        let startPosition = null;
        let totalTime = null;
        if (infoResults.data.length > 0) {
            const row = infoResults.data[0];
            startPosition = parseInt(row.ponto_inicial);
            totalTime = parseFloat(row.tempo_total);
            console.log("Loaded info CSV:", { startPosition, totalTime });
        }

        drawGraph();
        populateDropdowns();

        // You store totalTime globally
        window.totalTimeAvailable = totalTime;

        if (startPosition) {
            const startSelect = document.getElementById('startNode');
            startSelect.value = startPosition;

            // highlight in green
            const nodeSet = network.body.data.nodes;
            nodeSet.update({ id: startPosition, color: { background: 'lightgreen' } });
        }

    });


    function parseCSV(file) {
        return new Promise((resolve, reject) => {
            Papa.parse(file, {
                header: true,
                dynamicTyping: false,
                skipEmptyLines: true,
                complete: resolve,
                error: reject
            });
        });
    }

    function drawGraph() {
        const data = { nodes: new vis.DataSet(nodes), edges: new vis.DataSet(edges) };

        const options = {
            edges: { smooth: true },
            physics: { enabled: true, stabilization: { iterations: 200 } },
            layout: { improvedLayout: true }
        };

        network = new vis.Network(container, data, options);
        network.setOptions({
            edges: {
                smooth: {
                    type: "dynamic"
                },
            },
            physics: {
                enabled: true,
                solver: "forceAtlas2Based",  // works great for connected graphs
                forceAtlas2Based: {
                    gravitationalConstant: -100,   // more negative = more repulsion
                    centralGravity: 0.03,        // smaller = looser center pull
                    springLength: 50,            // longer edges = more spread
                    springConstant: 0.02          // smaller = looser springs
                },
                maxVelocity: 50,
                stabilization: { iterations: 500 },
            },
            layout: {
                improvedLayout: true
            },
            nodes: {
                shape: "ellipse",
                size: 15,
                font: { size: 14 }
            }
        })
        console.log("Loaded", nodes.length, "nodes and", edges.length, "edges");
    }

    // --- fixed A* that uses the edge.value consistently and validates inputs ---
    function aStar(startId, goalId) {
        // ensure startId/goalId are numbers
        startId = Number(startId);
        goalId = Number(goalId);

        const adj = {};
        for (const e of edges) {
            // use e.value (we populated it) as cost
            if (!adj[e.from]) adj[e.from] = [];
            adj[e.from].push({ to: e.to, cost: Number(e.value) });
        }

        const openSet = new Set([startId]);
        const cameFrom = {};
        const gScore = {}, fScore = {};
        for (const n of nodes) {
            gScore[n.id] = Infinity;
            fScore[n.id] = Infinity;
        }
        gScore[startId] = 0;
        fScore[startId] = 0;

        while (openSet.size > 0) {
            let current = [...openSet].reduce((a, b) => fScore[a] < fScore[b] ? a : b);

            if (current === goalId) return reconstructPath(cameFrom, current);

            openSet.delete(current);
            for (const neighbor of adj[current] || []) {
                const tentative = gScore[current] + neighbor.cost;
                if (tentative < gScore[neighbor.to]) {
                    cameFrom[neighbor.to] = current;
                    gScore[neighbor.to] = tentative;
                    fScore[neighbor.to] = tentative; // no heuristic for now
                    openSet.add(neighbor.to);
                }
            }
        }
        return null;
    }


    function reconstructPath(cameFrom, current) {
        const path = [current];
        while (cameFrom[current] !== undefined) {
            current = cameFrom[current];
            path.unshift(current);
        }
        return path;
    }

    // --- populate selects (call this after drawGraph()) ---
    function populateDropdowns() {
        const startSelect = document.getElementById('startNode');
        const goalSelect = document.getElementById('goalNode');

        startSelect.innerHTML = '';
        goalSelect.innerHTML = '';

        // placeholder with EMPTY value intentionally - we'll validate that later
        const placeholderStart = document.createElement('option');
        placeholderStart.value = "";
        placeholderStart.textContent = "Select start node...";
        placeholderStart.disabled = false; // keep selectable so .value is "" until user chooses
        placeholderStart.selected = true;
        startSelect.appendChild(placeholderStart);

        const placeholderGoal = document.createElement('option');
        placeholderGoal.value = "";
        placeholderGoal.textContent = "Select goal node...";
        placeholderGoal.disabled = false;
        placeholderGoal.selected = true;
        goalSelect.appendChild(placeholderGoal);

        nodes.forEach(n => {
            const opt1 = document.createElement('option');
            opt1.value = String(n.id);   // values are strings but contain numeric ids
            opt1.textContent = n.label;
            startSelect.appendChild(opt1);

            const opt2 = document.createElement('option');
            opt2.value = String(n.id);
            opt2.textContent = n.label;
            goalSelect.appendChild(opt2);
        });
    }

    // ambulance calculate function
    async function simulateAmbulance(startId, totalTime) {
        const patients = nodes.filter(n => n.type.toLowerCase() === "paciente");
        const hospitals = nodes.filter(n => n.type.toLowerCase() === "hospital");
        let current = startId;
        let timeLeft = totalTime;
        let totalScore = 0;
        const visited = new Set();
        const pathTaken = [];

        while (timeLeft > 0 && patients.some(p => !visited.has(p.id))) {

            // find nearest unvisited patient
            const unvisitedPatients = patients.filter(p => !visited.has(p.id));
            let bestPath = null;
            let bestCost = Infinity;
            let bestPatient = null;

            for (const p of unvisitedPatients) {
                const path = aStar(current, p.id);
                if (!path) continue;
                const cost = pathCost(path);
                if (cost < bestCost) {
                    bestCost = cost;
                    bestPath = path;
                    bestPatient = p;
                }
            }

            if (!bestPath) break;

            const totalToPatient = bestCost + parseFloat(bestPatient.cost);
            if (totalToPatient > timeLeft) break; // not enough time

            pathTaken.push(...bestPath.slice(1));
            timeLeft -= totalToPatient;
            visited.add(bestPatient.id);
            totalScore += bestPatient.score;
            current = bestPatient.id;

            // go to nearest hospital
            let nearestHospital = null;
            let hospitalPath = null;
            let hospitalCost = Infinity;

            for (const h of hospitals) {
                const path = aStar(current, h.id);
                if (!path) continue;
                const cost = pathCost(path);
                if (cost < hospitalCost) {
                    hospitalCost = cost;
                    hospitalPath = path;
                    nearestHospital = h;
                }
            }

            if (!hospitalPath) break;
            if (hospitalCost > timeLeft) break;

            pathTaken.push(...hospitalPath.slice(1));
            timeLeft -= hospitalCost;
            current = nearestHospital.id;
        }

        highlightPath(pathTaken);
        alert(`Simulation finished. Total score: ${totalScore.toFixed()} Time left: ${timeLeft.toFixed(1)} minutes`);
    }

    // Helper: compute path cost (sum of edge values)
    function pathCost(path) {
        let total = 0;
        for (let i = 0; i < path.length - 1; i++) {
            const e = edges.find(e =>
                (e.from === path[i] && e.to === path[i + 1]) ||
                (e.to === path[i] && e.from === path[i + 1])
            );
            if (e) total += e.value;
        }
        return total;
    }

    // Highlight path visually
    function highlightPath(path) {
        const edgeSet = network.body.data.edges;
        edgeSet.forEach(edge => {
            if (path.includes(edge.from) && path.includes(edge.to) &&
                path.indexOf(edge.to) === path.indexOf(edge.from) + 1)
                edgeSet.update({ id: edge.id, color: { color: 'red' }, width: 3 });
            else
                edgeSet.update({ id: edge.id, color: { color: '#848484' }, width: 1 });
        });
    }


    // --- updated click handler for "Find Path" (validates selections) ---
    document.getElementById('findPathBtn').addEventListener('click', () => {
        const startVal = document.getElementById('startNode').value;
        const goalVal = document.getElementById('goalNode').value;

        // validate that user selected both (placeholder has empty string "")
        if (!startVal || !goalVal) return alert("Enter both node IDs (select start and goal from the dropdowns)!");

        const start = parseInt(startVal, 10);
        const goal = parseInt(goalVal, 10);
        if (Number.isNaN(start) || Number.isNaN(goal)) return alert("Invalid node selection.");

        const path = aStar(start, goal);
        if (!path) return alert("No path found.");

        // highlight edges along the path
        const edgeSet = network.body.data.edges;
        edgeSet.forEach(edge => {
            // convert from/to numbers to compare
            const from = Number(edge.from);
            const to = Number(edge.to);
            if (path.includes(from) && path.includes(to) &&
                path.indexOf(to) === path.indexOf(from) + 1) {
                edgeSet.update({ id: edge.id, color: { color: 'red' }, width: 3 });
            } else {
                edgeSet.update({ id: edge.id, color: { color: '#848484' }, width: 1 });
            }
        });

        // alert("Path found: " + path.join(" â†’ "));
    });

    document.getElementById('resetColorsBtn').addEventListener('click', () => {
        if (!network) return;

        const edgeSet = network.body.data.edges;
        edgeSet.forEach(edge => {
            edgeSet.update({
                id: edge.id,
                color: { color: '#97C2FC' }, // default gray edge color
                width: 1
            });
        });
    });

    document.getElementById('simulateBtn').addEventListener('click', () => {
        const time = window.totalTimeAvailable;
        const start = parseInt(document.getElementById('startNode').value);
        if (!start || !time) return alert("Load info.csv first!");
        simulateAmbulance(start, time);
    });

</script>
</body>
</html>
